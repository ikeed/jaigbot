<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Gemini Flash Hello</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 2rem; }
    textarea { width: 100%; max-width: 720px; resize: none; overflow: hidden; box-sizing: border-box; line-height: 1.4; min-height: 3em; }
    button { margin-top: 0.5rem; padding: 0.5rem 1rem; }
    /* Output box should autosize to content and wrap long lines */
    pre#out {
      display: block;
      white-space: pre-wrap; /* keep newlines, allow wrapping */
      overflow-wrap: anywhere; /* wrap long tokens */
      word-break: break-word;
      background: #f7f7f7;
      padding: 1rem;
      border-radius: 6px;
      border: 1px solid #e3e3e3;
      max-width: 720px;
      min-height: 3.5rem; /* looks like a box even when empty */
      margin-top: 0.5rem;
    }
    #status { color: #666; font-size: 0.9rem; margin-left: 0.5rem; }
    .cfg-bar {
      margin: 0.5rem 0 1rem 0; padding: 0.5rem 0.75rem; border: 1px dashed #bdbdbd; border-radius: 6px; max-width: 720px;
      color: #333; background: #fafafa; font-size: 0.9rem;
    }
    .cfg-bar code { background: #fff; padding: 0.1rem 0.25rem; border: 1px solid #eee; border-radius: 4px; }
    .cfg-links { margin-top: 0.25rem; }
    .cfg-links a { color: #0b5ed7; text-decoration: none; }
    .cfg-links a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <h1>Gemini Flash Hello</h1>
  <p>Type a message and click Send. This calls the backend /chat, which proxies to Vertex AI Gemini Flash.</p>

  <div id="cfg" class="cfg-bar">
    <span id="cfgText">Loading configuration…</span>
    <div class="cfg-links">
      <a href="/config" target="_blank" rel="noreferrer">View /config</a>
      •
      <a href="/diagnostics" target="_blank" rel="noreferrer">View /diagnostics</a>
      •
      <a href="/healthz" target="_blank" rel="noreferrer">/healthz</a>
    </div>
  </div>

  <textarea id="msg" rows="3" placeholder="Say hello to Gemini..."></textarea><br>
  <button id="send">Send</button>
  <span id="status"></span>
  <h3>Reply</h3>
  <pre id="out"></pre>

  <script>
    const sendBtn = document.getElementById('send');
    const msgEl = document.getElementById('msg');
    const out = document.getElementById('out');
    const statusEl = document.getElementById('status');
    const cfgText = document.getElementById('cfgText');

    // Auto-size the input textarea to fit its content (robust across events)
    function autosize(el) {
      // Defer to next frame to ensure scrollHeight is updated after event
      requestAnimationFrame(() => {
        el.style.height = 'auto';
        el.style.height = el.scrollHeight + 'px';
      });
    }
    const autosizeEvents = ['input', 'change', 'cut', 'paste', 'drop', 'keydown'];
    autosizeEvents.forEach(ev => msgEl.addEventListener(ev, () => autosize(msgEl)));
    window.addEventListener('resize', () => autosize(msgEl));
    // Initialize sizing on load (handles autofill/remembered text)
    window.addEventListener('load', () => {
      autosize(msgEl);
      loadConfig();
    });

    async function loadConfig() {
      try {
        const res = await fetch('/config');
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const cfg = await res.json();
        const parts = [];
        if (cfg.modelId) parts.push(`model: ${cfg.modelId}`);
        if (cfg.region) parts.push(`region: ${cfg.region}`);
        if (typeof cfg.memoryBackend !== 'undefined') parts.push(`memory: ${cfg.memoryBackend} (size=${cfg.memoryStoreSize})`);
        if (typeof cfg.maxTokens !== 'undefined') parts.push(`maxTokens: ${cfg.maxTokens}`);
        cfgText.textContent = parts.join(' • ');
      } catch (e) {
        cfgText.textContent = `Config unavailable (${e && e.message ? e.message : e})`;
      }
    }

    async function send() {
      const message = msgEl.value.trim();
      if (!message) {
        out.textContent = 'Please enter a message.';
        return;
      }
      sendBtn.disabled = true;
      statusEl.textContent = 'Sending...';
      out.textContent = '';
      try {
        const res = await fetch('/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ message })
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          const err = (data && data.error && data.error.message) || `HTTP ${res.status}`;
          out.textContent = `Error: ${err}`;
        } else {
          out.textContent = data.reply || '';
        }
      } catch (e) {
        out.textContent = 'Network error: ' + (e && e.message ? e.message : e);
      } finally {
        sendBtn.disabled = false;
        statusEl.textContent = '';
      }
    }

    sendBtn.addEventListener('click', send);
    msgEl.addEventListener('keydown', (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') send();
    });
  </script>
</body>
</html>
